{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ESP32-Paxcounter Wifi & Bluetooth driven, LoRaWAN enabled, battery powered mini Paxcounter built on cheap ESP32 LoRa IoT boards Tutorial (in german language) Documentation : https://cyberman54.github.io/ESP32-Paxcounter Source Code : https://github.com/cyberman54/ESP32-Paxcounter Use case Paxcounter is an ESP32 MCU based device for metering passenger flows in realtime. It counts how many mobile devices are around. This gives an estimation how many people are around. Paxcounter detects Wifi and Bluetooth signals in the air, focusing on mobile devices by evaluating their MAC adresses. Info Intention of this project is to do this without intrusion in privacy: You don't need to track people owned devices, if you just want to count them. Therefore, Paxcounter does not persistenly store MAC adresses and *does no kind of fingerprinting the scanned devices. Data can either be be stored on a local SD-card, transferred to cloud using LoRaWAN network (e.g. TheThingsNetwork or Helium) or MQTT over TCP/IP, or transmitted to a local host using serial (SPI) interface. You can build this project battery powered using ESP32 deep sleep mode and reach long uptimes with a single 18650 Li-Ion cell. Impressions","title":"Intro"},{"location":"#esp32-paxcounter","text":"Wifi & Bluetooth driven, LoRaWAN enabled, battery powered mini Paxcounter built on cheap ESP32 LoRa IoT boards Tutorial (in german language) Documentation : https://cyberman54.github.io/ESP32-Paxcounter Source Code : https://github.com/cyberman54/ESP32-Paxcounter","title":"ESP32-Paxcounter"},{"location":"#use-case","text":"Paxcounter is an ESP32 MCU based device for metering passenger flows in realtime. It counts how many mobile devices are around. This gives an estimation how many people are around. Paxcounter detects Wifi and Bluetooth signals in the air, focusing on mobile devices by evaluating their MAC adresses. Info Intention of this project is to do this without intrusion in privacy: You don't need to track people owned devices, if you just want to count them. Therefore, Paxcounter does not persistenly store MAC adresses and *does no kind of fingerprinting the scanned devices. Data can either be be stored on a local SD-card, transferred to cloud using LoRaWAN network (e.g. TheThingsNetwork or Helium) or MQTT over TCP/IP, or transmitted to a local host using serial (SPI) interface. You can build this project battery powered using ESP32 deep sleep mode and reach long uptimes with a single 18650 Li-Ion cell.","title":"Use case"},{"location":"#impressions","text":"","title":"Impressions"},{"location":"display-led/","text":"Display If you're using a device with OLED display, or if you add such one to the I2C bus, the device shows live data on the display. You can flip display pages showing recent count of pax histogram GPS data BME sensor data time of day blank page by pressing the button of the device. LED blink pattern Mono color LED: Single Flash (50ms): seen a new Wifi or BLE device Quick blink (20ms on each 1/5 second): joining LoRaWAN network in progress or pending Small blink (10ms on each 1/2 second): LoRaWAN data transmit in progress or pending Long blink (200ms on each 2 seconds): LoRaWAN stack error RGB LED: Green: seen a new Wifi device Magenta: seen a new BLE device Yellow: joining LoRaWAN network in progress or pending Pink: LORAWAN MAC transmit in progress Blue: LoRaWAN data transmit in progress or pending Red: LoRaWAN stack errors","title":"Display & LED"},{"location":"display-led/#display","text":"If you're using a device with OLED display, or if you add such one to the I2C bus, the device shows live data on the display. You can flip display pages showing recent count of pax histogram GPS data BME sensor data time of day blank page by pressing the button of the device.","title":"Display"},{"location":"display-led/#led-blink-pattern","text":"Mono color LED: Single Flash (50ms): seen a new Wifi or BLE device Quick blink (20ms on each 1/5 second): joining LoRaWAN network in progress or pending Small blink (10ms on each 1/2 second): LoRaWAN data transmit in progress or pending Long blink (200ms on each 2 seconds): LoRaWAN stack error RGB LED: Green: seen a new Wifi device Magenta: seen a new BLE device Yellow: joining LoRaWAN network in progress or pending Pink: LORAWAN MAC transmit in progress Blue: LoRaWAN data transmit in progress or pending Red: LoRaWAN stack errors","title":"LED blink pattern"},{"location":"getting-started/","text":"Preparing Install Platformio Install PlatformIO IDE for embedded development to build this project. Platformio integrates with your favorite IDE, choose e.g. Visual Studio Code , Atom, Eclipse etc. Compile time configuration is spread across several files. Before compiling the code, edit or create the following files: platformio.ini Edit platformio_orig.ini (for ESP32 CPU based boards) or platformio_orig_s3.ini (for ESP32-S3 CPU based boards) and select desired board in section board . To add a new board, create an appropriate hardware abstraction layer file in hal subdirectory, and add a pointer to this file in section board . Copy or rename to platformio.ini in the root directory of the project. Now start Platformio. Selecting a board Uncomment your board 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 [board] ;halfile = generic.h ;halfile = ebox.h ;halfile = eboxtube.h ;halfile = ecopower.h ;halfile = heltec.h ;halfile = heltecv2.h ;halfile = heltecv21.h ;halfile = ttgov1.h ;halfile = ttgov2.h ;halfile = ttgov21old.h halfile = ttgov21new.h ;halfile = ttgofox.h ;halfile = ttgobeam.h ;halfile = ttgobeam10.h ;halfile = ttgotdisplay.h ;halfile = ttgotwristband.h ;halfile = fipy.h ;halfile = lopy.h ;halfile = lopy4.h ;halfile = lolin32litelora.h ;halfile = lolin32lora.h ;halfile = lolin32lite.h ;halfile = wemos32oled.h ;halfile = wemos32matrix.h ;halfile = octopus32.h ;halfile = tinypico.h ;halfile = tinypicomatrix.h ;halfile = m5core.h ;halfile = m5fire.h ;halfile = olimexpoeiso.h Copy Rename cp platformio_orig.ini platformio.ini mv platformio_orig.ini platformio.ini platformio_orig_s3.ini Copy Rename cp platformio_orig_s3.ini platformio.ini mv platformio_orig_s3.ini platformio.ini Info Platformio is looking for platformio.ini in the root directory and won't start if it does not find this file! paxcounter.conf Edit src/paxcounter_orig.conf and tailor settings in this file according to your needs and use case. Please take care of the duty cycle regulations of the LoRaWAN network you're going to use. Copy or rename to src/paxcounter.conf . Copy Rename cp src/paxcounter_orig.conf src/paxcounter.conf mv src/paxcounter_orig.conf src/paxcounter.conf If your device has a real time clock it can be updated by either LoRaWAN network or GPS time, according to settings TIME_SYNC_INTERVAL and TIME_SYNC_LORAWAN in paxcounter.conf . paxcounter.conf 85 // settings for syncing time of node with a time source (network / gps / rtc / timeserver) src/lmic_config.h Edit src/lmic_config.h and tailor settings in this file according to your country and device hardware. Please take care of national regulations when selecting the frequency band for LoRaWAN. national regulations in src/lmic_config.h 9 10 11 12 13 14 15 16 17 #define CFG_eu868 1 // Europe (high band) //#define CFG_eu433 1 // Europe (low band) //#define CFG_us915 1 // USA, Canada and South America //#define CFG_in866 1 // India //#define CFG_au915 1 // Australia //#define CFG_as923 1 // Asia //#define CFG_cn783 1 // China (high band) //#define CFG_cn490 1 // China (low band) //#define CFG_kr920 1 // Korea src/loraconf.h Create file src/loraconf.h using the template src/loraconf_sample.h and adjust settings to use your personal values. To join the network and activate your paxcounter, you must configure either OTAA or ABP join method. You should use OTAA, whenever possible. To understand the differences of the two methods, this article may be useful. Copy Rename cp src/loraconf_sample.h src/loraconf.h mv src/loraconf_sample.h src/loraconf.h To configure OTAA, leave #define LORA_ABP deactivated (commented). To use ABP, activate (uncomment) #define LORA_ABP in the file src/loraconf.h . The file src/loraconf_sample.h contains more information about the values to provide. Activate OTAA (Default), Deactivate ABP Deactivate OTAA, Activate ABP src/loraconf.h 18 //#define LORA_ABP src/loraconf.h 18 #define LORA_ABP src/ota.conf Create file src/ota.conf using the template src/ota_sample.conf and enter your WIFI network & key. These settings are used for downloading updates via WiFi, either from a remote https server, or locally via WebUI. If you want to use a remote server, you need a PAX.express repository . Enter your PAX.express credentials in ota.conf. If you don't need wireless firmware updates just rename ota.sample.conf to ota.conf. Copy Rename cp src/ota_sample.conf src/ota.conf mv src/ota_sample.conf src/ota.conf Building Use PlatformIO with your preferred IDE for development and building this code. Make sure you have latest PlatformIO version. Uploading Warning After editing paxcounter.conf , use \"clean\" button before \"build\" in PlatformIO! Clear NVRAM of the board to delete previous stored runtime settings ( pio run -t erase ) by cable, via USB/UART interface: To upload the code via cable to your ESP32 board this needs to be switched from run to bootloader mode. Boards with USB bridge like Heltec and TTGO usually have an onboard logic which allows soft switching by the upload tool. In PlatformIO this happenes automatically. The LoPy/LoPy4/FiPy board needs to be set manually. See these instructions how to do it. Don't forget to press on board reset button after switching between run and bootloader mode. The original Pycom firmware is not needed, so there is no need to update it before flashing Paxcounter. Just flash the compiled paxcounter binary (.elf file) on your LoPy/LoPy4/FiPy. If you later want to go back to the Pycom firmware, download the firmware from Pycom and flash it over. over the air (OTA), download via WiFi: After the ESP32 board is initially flashed and has joined a LoRaWAN network, the firmware can update itself by OTA. This process is kicked off by sending a remote control command (see below) via LoRaWAN to the board. The board then tries to connect via WiFi to a cloud service ( PAX.express ), checks for update, and if available downloads the binary and reboots with it. If something goes wrong during this process, the board reboots back to the current version. Prerequisites for OTA are: 1. You own a PAX.express repository, 2. you pushed the update binary to your PAX.express repository, 3. internet access via encrypted (WPA2) WiFi is present at the board's site, 4. WiFi credentials were set in ota.conf and initially flashed to the board. Step 2 runs automated, just enter the credentials in ota.conf and set upload_protocol = custom in platformio.ini. Then press build and lean back watching platformio doing build and upload. over the air (OTA), upload via WiFi: If option BOOTMENU is defined in paxcounter.conf , the ESP32 board will try to connect to a known WiFi access point each time cold starting (after a power cycle or a reset), using the WiFi credentials given in ota.conf . Once connected to the WiFi it will fire up a simple webserver, providing a bootstrap menu waiting for a user interaction (pressing \"START\" button in menu). This process will time out after BOOTDELAY seconds, ensuring booting the device to runmode. Once a user interaction in bootstrap menu was detected, the timeout will be extended to BOOTTIMEOUT seconds. During this time a firmware upload can be performed manually by user, e.g. using a smartphone in tethering mode providing the firmware upload file.","title":"Getting Started"},{"location":"getting-started/#preparing","text":"","title":"Preparing"},{"location":"getting-started/#install-platformio","text":"Install PlatformIO IDE for embedded development to build this project. Platformio integrates with your favorite IDE, choose e.g. Visual Studio Code , Atom, Eclipse etc. Compile time configuration is spread across several files. Before compiling the code, edit or create the following files:","title":"Install Platformio"},{"location":"getting-started/#platformioini","text":"Edit platformio_orig.ini (for ESP32 CPU based boards) or platformio_orig_s3.ini (for ESP32-S3 CPU based boards) and select desired board in section board . To add a new board, create an appropriate hardware abstraction layer file in hal subdirectory, and add a pointer to this file in section board . Copy or rename to platformio.ini in the root directory of the project. Now start Platformio.","title":"platformio.ini"},{"location":"getting-started/#selecting-a-board","text":"Uncomment your board 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 [board] ;halfile = generic.h ;halfile = ebox.h ;halfile = eboxtube.h ;halfile = ecopower.h ;halfile = heltec.h ;halfile = heltecv2.h ;halfile = heltecv21.h ;halfile = ttgov1.h ;halfile = ttgov2.h ;halfile = ttgov21old.h halfile = ttgov21new.h ;halfile = ttgofox.h ;halfile = ttgobeam.h ;halfile = ttgobeam10.h ;halfile = ttgotdisplay.h ;halfile = ttgotwristband.h ;halfile = fipy.h ;halfile = lopy.h ;halfile = lopy4.h ;halfile = lolin32litelora.h ;halfile = lolin32lora.h ;halfile = lolin32lite.h ;halfile = wemos32oled.h ;halfile = wemos32matrix.h ;halfile = octopus32.h ;halfile = tinypico.h ;halfile = tinypicomatrix.h ;halfile = m5core.h ;halfile = m5fire.h ;halfile = olimexpoeiso.h Copy Rename cp platformio_orig.ini platformio.ini mv platformio_orig.ini platformio.ini platformio_orig_s3.ini Copy Rename cp platformio_orig_s3.ini platformio.ini mv platformio_orig_s3.ini platformio.ini Info Platformio is looking for platformio.ini in the root directory and won't start if it does not find this file!","title":"Selecting a board"},{"location":"getting-started/#paxcounterconf","text":"Edit src/paxcounter_orig.conf and tailor settings in this file according to your needs and use case. Please take care of the duty cycle regulations of the LoRaWAN network you're going to use. Copy or rename to src/paxcounter.conf . Copy Rename cp src/paxcounter_orig.conf src/paxcounter.conf mv src/paxcounter_orig.conf src/paxcounter.conf If your device has a real time clock it can be updated by either LoRaWAN network or GPS time, according to settings TIME_SYNC_INTERVAL and TIME_SYNC_LORAWAN in paxcounter.conf . paxcounter.conf 85 // settings for syncing time of node with a time source (network / gps / rtc / timeserver)","title":"paxcounter.conf"},{"location":"getting-started/#srclmic_configh","text":"Edit src/lmic_config.h and tailor settings in this file according to your country and device hardware. Please take care of national regulations when selecting the frequency band for LoRaWAN. national regulations in src/lmic_config.h 9 10 11 12 13 14 15 16 17 #define CFG_eu868 1 // Europe (high band) //#define CFG_eu433 1 // Europe (low band) //#define CFG_us915 1 // USA, Canada and South America //#define CFG_in866 1 // India //#define CFG_au915 1 // Australia //#define CFG_as923 1 // Asia //#define CFG_cn783 1 // China (high band) //#define CFG_cn490 1 // China (low band) //#define CFG_kr920 1 // Korea","title":"src/lmic_config.h"},{"location":"getting-started/#srcloraconfh","text":"Create file src/loraconf.h using the template src/loraconf_sample.h and adjust settings to use your personal values. To join the network and activate your paxcounter, you must configure either OTAA or ABP join method. You should use OTAA, whenever possible. To understand the differences of the two methods, this article may be useful. Copy Rename cp src/loraconf_sample.h src/loraconf.h mv src/loraconf_sample.h src/loraconf.h To configure OTAA, leave #define LORA_ABP deactivated (commented). To use ABP, activate (uncomment) #define LORA_ABP in the file src/loraconf.h . The file src/loraconf_sample.h contains more information about the values to provide. Activate OTAA (Default), Deactivate ABP Deactivate OTAA, Activate ABP src/loraconf.h 18 //#define LORA_ABP src/loraconf.h 18 #define LORA_ABP","title":"src/loraconf.h"},{"location":"getting-started/#srcotaconf","text":"Create file src/ota.conf using the template src/ota_sample.conf and enter your WIFI network & key. These settings are used for downloading updates via WiFi, either from a remote https server, or locally via WebUI. If you want to use a remote server, you need a PAX.express repository . Enter your PAX.express credentials in ota.conf. If you don't need wireless firmware updates just rename ota.sample.conf to ota.conf. Copy Rename cp src/ota_sample.conf src/ota.conf mv src/ota_sample.conf src/ota.conf","title":"src/ota.conf"},{"location":"getting-started/#building","text":"Use PlatformIO with your preferred IDE for development and building this code. Make sure you have latest PlatformIO version.","title":"Building"},{"location":"getting-started/#uploading","text":"Warning After editing paxcounter.conf , use \"clean\" button before \"build\" in PlatformIO! Clear NVRAM of the board to delete previous stored runtime settings ( pio run -t erase ) by cable, via USB/UART interface: To upload the code via cable to your ESP32 board this needs to be switched from run to bootloader mode. Boards with USB bridge like Heltec and TTGO usually have an onboard logic which allows soft switching by the upload tool. In PlatformIO this happenes automatically. The LoPy/LoPy4/FiPy board needs to be set manually. See these instructions how to do it. Don't forget to press on board reset button after switching between run and bootloader mode. The original Pycom firmware is not needed, so there is no need to update it before flashing Paxcounter. Just flash the compiled paxcounter binary (.elf file) on your LoPy/LoPy4/FiPy. If you later want to go back to the Pycom firmware, download the firmware from Pycom and flash it over. over the air (OTA), download via WiFi: After the ESP32 board is initially flashed and has joined a LoRaWAN network, the firmware can update itself by OTA. This process is kicked off by sending a remote control command (see below) via LoRaWAN to the board. The board then tries to connect via WiFi to a cloud service ( PAX.express ), checks for update, and if available downloads the binary and reboots with it. If something goes wrong during this process, the board reboots back to the current version. Prerequisites for OTA are: 1. You own a PAX.express repository, 2. you pushed the update binary to your PAX.express repository, 3. internet access via encrypted (WPA2) WiFi is present at the board's site, 4. WiFi credentials were set in ota.conf and initially flashed to the board. Step 2 runs automated, just enter the credentials in ota.conf and set upload_protocol = custom in platformio.ini. Then press build and lean back watching platformio doing build and upload. over the air (OTA), upload via WiFi: If option BOOTMENU is defined in paxcounter.conf , the ESP32 board will try to connect to a known WiFi access point each time cold starting (after a power cycle or a reset), using the WiFi credentials given in ota.conf . Once connected to the WiFi it will fire up a simple webserver, providing a bootstrap menu waiting for a user interaction (pressing \"START\" button in menu). This process will time out after BOOTDELAY seconds, ensuring booting the device to runmode. Once a user interaction in bootstrap menu was detected, the timeout will be extended to BOOTTIMEOUT seconds. During this time a firmware upload can be performed manually by user, e.g. using a smartphone in tethering mode providing the firmware upload file.","title":"Uploading"},{"location":"hardware/","text":"Hardware Supported ESP32 based boards: With LoRa radio data transfer : LilyGo: Paxcounter-Board* TTGO: T1 , T2 , T3*, T-Beam, T-Fox Heltec: LoRa-32 v1 and v2 Pycom: LoPy, LoPy4, FiPy Radioshuttle.de: ECO Power Board WeMos: LoLin32 + LoraNode32 shield , LoLin32lite + LoraNode32-Lite shield Adafruit ESP32 Feather + LoRa Wing + OLED Wing, #IoT Octopus32 (Octopus + ESP32 Feather) M5Stack: Basic Core IoT* + Lora Module RA-01H , Fire IoT* Without LoRa : LilyGo: T-Dongle S3* Pyom: WiPy WeMos: LoLin32, LoLin32 Lite, WeMos D32, Wemos32 Oled Crowdsupply: TinyPICO TTGO: T-Display TTGO: T-Wristband Generic ESP32 *) supports microSD/TF-card for local logging of paxcounter data Depending on board hardware following features are supported: LoRaWAN communication, supporting various payload formats (see enclosed .js converters) MQTT communication via TCP/IP and Ethernet interface (note: payload transmitted over MQTT will be base64 encoded) SPI serial communication to a local host LED (shows power & status) OLED Display (shows detailed status) RGB LED (shows colorized status) Button (short press: flip display page / long press: send alarm message) Battery voltage monitoring (analog read / AXP192 / IP5306) GPS (Generic serial NMEA, or Quectel L76 I2C) Environmental sensors (Bosch BMP180/BME280/BME680 I2C; SDS011 serial) Real Time Clock (Maxim DS3231 I2C) IF482 (serial) and DCF77 (gpio) time telegram generator Switch external power / battery LED Matrix display (similar to this 64x16 model , can be ordered on Aliexpress ) SD-card (see section SD-card here) for logging pax data Target platform must be selected in platformio.ini . Hardware dependent settings (pinout etc.) are stored in board files in /hal directory. If you want to use a ESP32 board which is not yet supported, use hal file generic.h and tailor pin mappings to your needs. Pull requests for new boards welcome. 3D printed cases Some 3D printable cases can be found (and, if wanted so, ordered) on Thingiverse, see Heltec TTGOv2 TTGOv2.1 TTGO T-BEAM T-BEAM parts Power consumption Power consumption was metered at around 450 - 1000mW, depending on board and user settings in paxcounter.conf . By default, bluetooth sniffing is not started. If you enable bluetooth be aware that this goes on expense of wifi sniffing results, because then wifi and bt stack must share the 2,4 GHz RF ressources of ESP32. If you need to sniff wifi and bt in parallel and need best possible results, use two boards - one for wifi only and one for bt only - and add counted results. Deactivate BLE sniffing (Default) Activate BLE sniffing paxcounter.conf 29 #define BLECOUNTER 0 paxcounter.conf 29 #define BLECOUNTER 1","title":"Hardware"},{"location":"hardware/#hardware","text":"","title":"Hardware"},{"location":"hardware/#supported-esp32-based-boards","text":"With LoRa radio data transfer : LilyGo: Paxcounter-Board* TTGO: T1 , T2 , T3*, T-Beam, T-Fox Heltec: LoRa-32 v1 and v2 Pycom: LoPy, LoPy4, FiPy Radioshuttle.de: ECO Power Board WeMos: LoLin32 + LoraNode32 shield , LoLin32lite + LoraNode32-Lite shield Adafruit ESP32 Feather + LoRa Wing + OLED Wing, #IoT Octopus32 (Octopus + ESP32 Feather) M5Stack: Basic Core IoT* + Lora Module RA-01H , Fire IoT* Without LoRa : LilyGo: T-Dongle S3* Pyom: WiPy WeMos: LoLin32, LoLin32 Lite, WeMos D32, Wemos32 Oled Crowdsupply: TinyPICO TTGO: T-Display TTGO: T-Wristband Generic ESP32 *) supports microSD/TF-card for local logging of paxcounter data Depending on board hardware following features are supported: LoRaWAN communication, supporting various payload formats (see enclosed .js converters) MQTT communication via TCP/IP and Ethernet interface (note: payload transmitted over MQTT will be base64 encoded) SPI serial communication to a local host LED (shows power & status) OLED Display (shows detailed status) RGB LED (shows colorized status) Button (short press: flip display page / long press: send alarm message) Battery voltage monitoring (analog read / AXP192 / IP5306) GPS (Generic serial NMEA, or Quectel L76 I2C) Environmental sensors (Bosch BMP180/BME280/BME680 I2C; SDS011 serial) Real Time Clock (Maxim DS3231 I2C) IF482 (serial) and DCF77 (gpio) time telegram generator Switch external power / battery LED Matrix display (similar to this 64x16 model , can be ordered on Aliexpress ) SD-card (see section SD-card here) for logging pax data Target platform must be selected in platformio.ini . Hardware dependent settings (pinout etc.) are stored in board files in /hal directory. If you want to use a ESP32 board which is not yet supported, use hal file generic.h and tailor pin mappings to your needs. Pull requests for new boards welcome.","title":"Supported ESP32 based boards:"},{"location":"hardware/#3d-printed-cases","text":"Some 3D printable cases can be found (and, if wanted so, ordered) on Thingiverse, see Heltec TTGOv2 TTGOv2.1 TTGO T-BEAM T-BEAM parts","title":"3D printed cases"},{"location":"hardware/#power-consumption","text":"Power consumption was metered at around 450 - 1000mW, depending on board and user settings in paxcounter.conf . By default, bluetooth sniffing is not started. If you enable bluetooth be aware that this goes on expense of wifi sniffing results, because then wifi and bt stack must share the 2,4 GHz RF ressources of ESP32. If you need to sniff wifi and bt in parallel and need best possible results, use two boards - one for wifi only and one for bt only - and add counted results. Deactivate BLE sniffing (Default) Activate BLE sniffing paxcounter.conf 29 #define BLECOUNTER 0 paxcounter.conf 29 #define BLECOUNTER 1","title":"Power consumption"},{"location":"integrations/","text":"Integration LoRaWAN \"The Things Stack Community Edition\" aka \"The Things Stack V3\" To use the ESP32-Paxcounter in The Things Stack Community Edition you need an account to reach the console. Go to: The Things Stack Community Edition Console choose your region and go to applications create an application by clicking \" + Add application \" and give it a id, name, etc. create a device by clicking \" + Add end device \" Select the end device: choose the Brand \" Open Source Community Projects \" and the Model \" ESP32-Paxcounter \", leave Hardware Version to \" Unknown \" and select your Firmware Version and Profile (Region) Enter registration data: choose the frequency plan (for EU choose the recommended), set the AppEUI (Fill with zeros), set the DeviceEUI (generate), set the AppKey (generate), choose a device ID and hit \"Register end device\" got to Applications -> \"your App ID\" -> Payload formatters -> Uplink, choose \" Repository \" and hit \"Save changes\" The \"Repository\" payload decoder uses the packed format, explained below. If you want to use MyDevices from Cayenne you should use the Cayenne payload decoder instead. TTN Mapper If you want your devices to be feeding the TTN Mapper , just follow this manual: https://docs.ttnmapper.org/integration/tts-integration-v3.html - different than indicated in the manual you can leave the payload decoder to \"Repository\" for the ESP32-Paxcounter and you are fine. ChirpStack Todo","title":"Integrations"},{"location":"integrations/#integration-lorawan","text":"","title":"Integration LoRaWAN"},{"location":"integrations/#the-things-stack-community-edition-aka-the-things-stack-v3","text":"To use the ESP32-Paxcounter in The Things Stack Community Edition you need an account to reach the console. Go to: The Things Stack Community Edition Console choose your region and go to applications create an application by clicking \" + Add application \" and give it a id, name, etc. create a device by clicking \" + Add end device \" Select the end device: choose the Brand \" Open Source Community Projects \" and the Model \" ESP32-Paxcounter \", leave Hardware Version to \" Unknown \" and select your Firmware Version and Profile (Region) Enter registration data: choose the frequency plan (for EU choose the recommended), set the AppEUI (Fill with zeros), set the DeviceEUI (generate), set the AppKey (generate), choose a device ID and hit \"Register end device\" got to Applications -> \"your App ID\" -> Payload formatters -> Uplink, choose \" Repository \" and hit \"Save changes\" The \"Repository\" payload decoder uses the packed format, explained below. If you want to use MyDevices from Cayenne you should use the Cayenne payload decoder instead.","title":"\"The Things Stack Community Edition\" aka \"The Things Stack V3\""},{"location":"integrations/#ttn-mapper","text":"If you want your devices to be feeding the TTN Mapper , just follow this manual: https://docs.ttnmapper.org/integration/tts-integration-v3.html - different than indicated in the manual you can leave the payload decoder to \"Repository\" for the ESP32-Paxcounter and you are fine.","title":"TTN Mapper"},{"location":"integrations/#chirpstack","text":"Todo","title":"ChirpStack"},{"location":"legalnote/","text":"Legal note Depending on your country's laws it may be illegal to sniff wireless networks for MAC addresses. Please check and respect your country's laws before using this code! (e.g. US citizens may want to check Section 18 U.S. Code \u00a7 2511 and discussion on this) (e.g. UK citizens may want to check Data Protection Act 1998 and GDPR 2018 ) (e.g. Citizens in the the Netherlands and EU may want to read this article and this article and this decision ) (e.g. Citizens in Germany may want to read this article of Wissenschaftliche Dienste des Deutschen Bundestages ) Info If you use this software you do this at your own risk. That means that you alone - not the authors of this software - are responsible for the legal compliance of an application using this or build from this software and/or usage of a device created using this software. You should take special care and get prior legal advice if you plan metering passengers in public areas and/or publish data drawn from doing so. Privacy disclosure Paxcounter generates identifiers for sniffed Wifi or Bluetooth MAC adresses and and collects them temporary in the device's RAM for a configurable scan cycle time (default 60 seconds). After each scan cycle the collected identifiers are cleared. Identifiers are generated by using the last 2 bytes of universal MAC adresses. Personal MAC adresses remain untouched and are not evaluated. Identifiers and MAC adresses are never transferred to the LoRaWAN network. No persistent storing of MAC adresses, identifiers or timestamps and no other kind of analytics than counting are implemented in this code. Wireless networks are not touched by this code, but MAC adresses from wireless devices as well within as not within wireless networks, regardless if encrypted or unencrypted, are sniffed and processed by this code.","title":"Legal note"},{"location":"legalnote/#legal-note","text":"Depending on your country's laws it may be illegal to sniff wireless networks for MAC addresses. Please check and respect your country's laws before using this code! (e.g. US citizens may want to check Section 18 U.S. Code \u00a7 2511 and discussion on this) (e.g. UK citizens may want to check Data Protection Act 1998 and GDPR 2018 ) (e.g. Citizens in the the Netherlands and EU may want to read this article and this article and this decision ) (e.g. Citizens in Germany may want to read this article of Wissenschaftliche Dienste des Deutschen Bundestages ) Info If you use this software you do this at your own risk. That means that you alone - not the authors of this software - are responsible for the legal compliance of an application using this or build from this software and/or usage of a device created using this software. You should take special care and get prior legal advice if you plan metering passengers in public areas and/or publish data drawn from doing so.","title":"Legal note"},{"location":"legalnote/#privacy-disclosure","text":"Paxcounter generates identifiers for sniffed Wifi or Bluetooth MAC adresses and and collects them temporary in the device's RAM for a configurable scan cycle time (default 60 seconds). After each scan cycle the collected identifiers are cleared. Identifiers are generated by using the last 2 bytes of universal MAC adresses. Personal MAC adresses remain untouched and are not evaluated. Identifiers and MAC adresses are never transferred to the LoRaWAN network. No persistent storing of MAC adresses, identifiers or timestamps and no other kind of analytics than counting are implemented in this code. Wireless networks are not touched by this code, but MAC adresses from wireless devices as well within as not within wireless networks, regardless if encrypted or unencrypted, are sniffed and processed by this code.","title":"Privacy disclosure"},{"location":"license-credits/","text":"License Copyright 2018-2022 Oliver Brandmueller ob@sysadm.in Copyright 2018-2022 Klaus Wilting verkehrsrot@arcor.de Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Info Parts of the source files in this repository are made available under different licenses, see file LICENSE.txt in this repository. Refer to each individual source file for more details. Credits Thanks to Oliver Brandm\u00fcller for idea and initial setup of this project Charles Hallard for major code contributions to this project robbi5 for the payload converter Caspar Armster for the The Things Stack V3 payload converter terrillmoore for maintaining the LMIC for arduino LoRaWAN stack sbamueller for writing the tutorial in Make Magazine Stefan for paxcounter opensensebox integration August Quint for adding SD card data logger and SDS011 support t-huyeng for adding a CI workflow and rework documentation","title":"Licence & Credits"},{"location":"license-credits/#license","text":"Copyright 2018-2022 Oliver Brandmueller ob@sysadm.in Copyright 2018-2022 Klaus Wilting verkehrsrot@arcor.de Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Info Parts of the source files in this repository are made available under different licenses, see file LICENSE.txt in this repository. Refer to each individual source file for more details.","title":"License"},{"location":"license-credits/#credits","text":"Thanks to Oliver Brandm\u00fcller for idea and initial setup of this project Charles Hallard for major code contributions to this project robbi5 for the payload converter Caspar Armster for the The Things Stack V3 payload converter terrillmoore for maintaining the LMIC for arduino LoRaWAN stack sbamueller for writing the tutorial in Make Magazine Stefan for paxcounter opensensebox integration August Quint for adding SD card data logger and SDS011 support t-huyeng for adding a CI workflow and rework documentation","title":"Credits"},{"location":"payloadformat/","text":"Payload format You can select different payload formats in paxcounter.conf : Plain uses big endian format and generates json fields, e.g. useful for TTN console Packed uses little endian format and generates json fields CayenneLPP generates MyDevices Cayenne readable fields src/paxcounter_orig.conf 20 #define SLEEPCYCLE 0 // sleep time after a send cycle [seconds/10], 0 .. 65535; 0 means no sleep [default = 0] Decrepated information from the things network v2 If you're using TheThingsNetwork (TTN) you may want to use a payload converter. Go to TTN Console - Application - Payload Formats and paste the code example below in tabs Decoder and Converter. This way your MQTT application can parse the fields pax , ble and wifi . To add your device to myDevices Cayenne platform select \"Cayenne-LPP\" from Lora device list and use the CayenneLPP payload encoder. To track a paxcounter device with on board GPS and at the same time contribute to TTN coverage mapping, you simply activate the TTNmapper integration in TTN Console. Both formats plain and packed generate the fields latitude , longitude and hdop required by ttnmapper. Important: set TTN mapper port filter to '4' (paxcounter GPS Port). Hereafter described is the default plain format, which uses MSB bit numbering. Under /TTN in this repository you find some ready-to-go decoders which you may copy to your TTN console: plain_decoder.js | plain_converter.js | packed_decoder.js | packed_converter.js Port #1: Paxcount data byte 1-2: Number of unique devices, seen on Wifi [00 00 if Wifi scan disabled] byte 3-4: Number of unique devices, seen on Bluetooth [ommited if BT scan disabled] Port #2: Device status query result byte 1-2: Battery or USB Voltage [mV], 0 if no battery probe byte 3-10: Uptime [seconds] byte 11: CPU temperature [\u00b0C] bytes 12-15: Free RAM [bytes] byte 16: Last CPU core 0 reset reason bytes 17-20: Number of restarts since last power cycle Port #3: Device configuration query result byte 1: Lora DR (0..15, see rcommand 0x05) [default 5] byte 2: Lora TXpower (2..15) [default 15] byte 3: Lora ADR (1=on, 0=off) [default 1] byte 4: Screensaver status (1=on, 0=off) [default 0] byte 5: Display status (1=on, 0=off) [default 0] byte 6: Counter mode (0=cyclic unconfirmed, 1=cumulative, 2=cyclic confirmed) [default 0] bytes 7-8: RSSI limiter threshold value (negative, MSB) [default 0] byte 9: Scan and send cycle in seconds/2 (0..255) [default 120] byte 10: Wifi channel hopping interval in seconds/100 (0..255), 0 means no hopping [default 50] byte 11: Bluetooth channel switch interval in seconds/100 (0..255) [default 10] byte 12: Bluetooth scanner status (1=on, 0=0ff) [default 1] byte 13: Wifi antenna switch (0=internal, 1=external) [default 0] bytes 14-15: Sleep cycle in seconds/10 (MSB) [default 0] byte 16: Payloadmask (Bitmask, 0..255, see rcommand 0x14) byte 17: 0 (reserved) bytes 18-28: Software version (ASCII format, terminating with zero) Port #4: GPS data (only if device has fature GPS, and GPS data is enabled and GPS has a fix) bytes 1-4: Latitude bytes 5-8: Longitude byte 9: Number of satellites bytes 10-11: HDOP bytes 12-13: Altitude [meter] Port #5: Button pressed alarm byte 1: static value 0x01 Port #6: (unused) Port #7: Environmental sensor data (only if device has feature BME) bytes 1-2: Temperature [\u00b0C] bytes 3-4: Pressure [hPa] bytes 5-6: Humidity [%] bytes 7-8: Indoor air quality index (0..500), see below Indoor air quality classification: 0-50 good 51-100 average 101-150 little bad 151-200 bad 201-300 worse 301-500 very bad Port #8: Battery voltage data (only if device has feature BATT) bytes 1-2: Battery or USB Voltage [mV], 0 if no battery probe Port #9: Time/Date bytes 1-4: board's local time/date in UNIX epoch (number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds) Ports #10, #11, #12: User sensor data Format is specified by user in function `sensor_read(uint8_t sensor)`, see `src/sensor.cpp`.","title":"Payload Format"},{"location":"payloadformat/#payload-format","text":"You can select different payload formats in paxcounter.conf : Plain uses big endian format and generates json fields, e.g. useful for TTN console Packed uses little endian format and generates json fields CayenneLPP generates MyDevices Cayenne readable fields src/paxcounter_orig.conf 20 #define SLEEPCYCLE 0 // sleep time after a send cycle [seconds/10], 0 .. 65535; 0 means no sleep [default = 0] Decrepated information from the things network v2 If you're using TheThingsNetwork (TTN) you may want to use a payload converter. Go to TTN Console - Application - Payload Formats and paste the code example below in tabs Decoder and Converter. This way your MQTT application can parse the fields pax , ble and wifi . To add your device to myDevices Cayenne platform select \"Cayenne-LPP\" from Lora device list and use the CayenneLPP payload encoder. To track a paxcounter device with on board GPS and at the same time contribute to TTN coverage mapping, you simply activate the TTNmapper integration in TTN Console. Both formats plain and packed generate the fields latitude , longitude and hdop required by ttnmapper. Important: set TTN mapper port filter to '4' (paxcounter GPS Port). Hereafter described is the default plain format, which uses MSB bit numbering. Under /TTN in this repository you find some ready-to-go decoders which you may copy to your TTN console: plain_decoder.js | plain_converter.js | packed_decoder.js | packed_converter.js Port #1: Paxcount data byte 1-2: Number of unique devices, seen on Wifi [00 00 if Wifi scan disabled] byte 3-4: Number of unique devices, seen on Bluetooth [ommited if BT scan disabled] Port #2: Device status query result byte 1-2: Battery or USB Voltage [mV], 0 if no battery probe byte 3-10: Uptime [seconds] byte 11: CPU temperature [\u00b0C] bytes 12-15: Free RAM [bytes] byte 16: Last CPU core 0 reset reason bytes 17-20: Number of restarts since last power cycle Port #3: Device configuration query result byte 1: Lora DR (0..15, see rcommand 0x05) [default 5] byte 2: Lora TXpower (2..15) [default 15] byte 3: Lora ADR (1=on, 0=off) [default 1] byte 4: Screensaver status (1=on, 0=off) [default 0] byte 5: Display status (1=on, 0=off) [default 0] byte 6: Counter mode (0=cyclic unconfirmed, 1=cumulative, 2=cyclic confirmed) [default 0] bytes 7-8: RSSI limiter threshold value (negative, MSB) [default 0] byte 9: Scan and send cycle in seconds/2 (0..255) [default 120] byte 10: Wifi channel hopping interval in seconds/100 (0..255), 0 means no hopping [default 50] byte 11: Bluetooth channel switch interval in seconds/100 (0..255) [default 10] byte 12: Bluetooth scanner status (1=on, 0=0ff) [default 1] byte 13: Wifi antenna switch (0=internal, 1=external) [default 0] bytes 14-15: Sleep cycle in seconds/10 (MSB) [default 0] byte 16: Payloadmask (Bitmask, 0..255, see rcommand 0x14) byte 17: 0 (reserved) bytes 18-28: Software version (ASCII format, terminating with zero) Port #4: GPS data (only if device has fature GPS, and GPS data is enabled and GPS has a fix) bytes 1-4: Latitude bytes 5-8: Longitude byte 9: Number of satellites bytes 10-11: HDOP bytes 12-13: Altitude [meter] Port #5: Button pressed alarm byte 1: static value 0x01 Port #6: (unused) Port #7: Environmental sensor data (only if device has feature BME) bytes 1-2: Temperature [\u00b0C] bytes 3-4: Pressure [hPa] bytes 5-6: Humidity [%] bytes 7-8: Indoor air quality index (0..500), see below Indoor air quality classification: 0-50 good 51-100 average 101-150 little bad 151-200 bad 201-300 worse 301-500 very bad Port #8: Battery voltage data (only if device has feature BATT) bytes 1-2: Battery or USB Voltage [mV], 0 if no battery probe Port #9: Time/Date bytes 1-4: board's local time/date in UNIX epoch (number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds) Ports #10, #11, #12: User sensor data Format is specified by user in function `sensor_read(uint8_t sensor)`, see `src/sensor.cpp`.","title":"Payload format"},{"location":"releases/","text":"Releases See all releases at https://github.com/cyberman54/ESP32-Paxcounter/releases .","title":"Releases"},{"location":"releases/#releases","text":"See all releases at https://github.com/cyberman54/ESP32-Paxcounter/releases .","title":"Releases"},{"location":"remotecontrol/","text":"Remote control The device listenes for remote control commands on LoRaWAN Port 2. Multiple commands per downlink are possible by concatenating them, but must not exceed a maximum of 10 bytes per downlink. Info Settings can be stored in NVRAM to make them persistant (reloaded during device startup / restart). To store settings, use command 0x21 . Send for example 83 86 as Downlink on Port 2 to get battery status and time/date from the device. 0x01 set scan RSSI limit 1 ... 255 used for wifi and bluetooth scan radius (greater values increase scan radius, values 50...110 make sense) 0 = RSSI limiter disabled [default] 0x02 set counter mode 0 = cyclic unconfirmed, mac counter reset after each wifi scan cycle, data is sent only once [default] 1 = cumulative counter, mac counter is never reset 2 = cyclic confirmed, like 0 but data is resent until confirmation by network received 0x03 set GPS data on/off 0 = GPS data off 1 = GPS data on, sends GPS data on port 4 (default, use port 1 for mobile pax counter), if GPS is present and has a fix 0x04 set display on/off 0 = display off 1 = display on [default] 0x05 set LoRa datarate 0 ... 15 see LoRaWAN regional parameters for details [default: 5] Example for EU868: DataRate Configuration Bit/s 0 LoRa: SF12 / 125 kHz 250 1 LoRa: SF11 / 125 kHz 440 2 LoRa: SF10 / 125 kHz 980 3 LoRa: SF9 / 125 kHz 1760 4 LoRa: SF8 / 125 kHz 3125 5 LoRa: SF7 / 125 kHz 5470 6* LoRa: SF7 / 250 kHz 11000 7* FSK: 50 kbps 50000 8 .. 14 reserved for future use (RFU) 15 ignored (device keeps current setting) *) not supported by TheThingsNetwork 0x06 set LoRa TXpower 0 ... 255 desired TX power in dBm [default: 14] 0x07 set LoRa Adaptive Data Rate mode 0 = ADR off 1 = ADR on [default] If ADR is set to off, SF value is shown inverted on display. 0x08 do nothing useful to clear pending commands from LoRaWAN server quere, or to check RSSI on device 0x09 reset functions (send this command UNconfirmed only to avoid boot loops!) 0 = restart device (coldstart) 1 = (reserved, currently does nothing) 2 = reset device to factory settings and restart device 3 = flush send queues 4 = restart device (warmstart) 8 = reboot device to maintenance mode (local web server) 9 = reboot device to OTA update via Wifi mode 0x0A set payload send cycle 5 ... 255 payload send cycle in seconds/2 e.g. 120 -> payload is transmitted each 240 seconds [default] 0x0B set Wifi channel hopping interval timer 0 ... 255 duration for scanning a wifi channel in seconds/100 e.g. 50 -> each channel is scanned for 500 milliseconds [default] 0 means no hopping, scanning on fixed single channel WIFI_CHANNEL_1 0x0C set Bluetooth channel switch interval timer 0 ... 255 duration for scanning a bluetooth advertising channel in seconds/100 e.g. 8 -> each channel is scanned for 80 milliseconds [default] 0x0E set Bluetooth scanner 0 = disabled 1 = enabled [default] 0x0F set WIFI antenna switch (works on LoPy/LoPy4/FiPy only) 0 = internal antenna [default] 1 = external antenna 0x10 set RGB led luminosity (works on LoPy/LoPy4/FiPy and LoRaNode32 shield only) 0 ... 100 percentage of luminosity (100% = full light) e.g. 50 -> 50% of luminosity [default] 0x13 set user sensor mode byte 1 = user sensor number (1..3) byte 2 = sensor mode (0 = disabled / 1 = enabled [default]) 0x14 set payload mask byte 1 = sensor data payload mask (0..255, meaning of bits see below) 0x01 = COUNT_DATA 0x02 = RESERVED_DATA 0x04 = MEMS_DATA 0x08 = GPS_DATA 0x10 = SENSOR_1_DATA 0x20 = SENSOR_2_DATA 0x40 = SENSOR_3_DATA 0x80 = BATT_DATA bytes can be combined eg COUNT_DATA + SENSOR_1_DATA + BATT_DATA: `0x01 | 0x10 | 0x80 = 0x91` 0x15 set BME data on/off 0 = BME data off 1 = BME data on, sends BME data on port 7 [default] 0x16 set battery data on/off 0 = battery data off [default] 1 = battery data on, sends voltage on port 8 0x17 set Wifi scanner 0 = disabled 1 = enabled [default] 0x18 reserved unused, does nothing 0x19 set sleep cycle bytes 1..2 = device sleep cycle in seconds/10 (MSB), 0..65535 (0 = no sleep) e.g. {0x04, 0xB0} -> device sleeps 200 minutes after each send cycle [default = 0] 0x20 load device configuration Current device runtime configuration will be loaded from NVRAM, replacing current settings immediately (use with care!) 0x21 store device configuration Current device runtime configuration is stored in NVRAM, will be reloaded after restart 0x80 get device configuration Device answers with it's current configuration on Port 3. 0x81 get device status Device answers with it's current status on Port 2. 0x83 get battery status Device answers with battery voltage on Port 8. 0x84 get device GPS status Device answers with it's current status on Port 4. 0x85 get BME280 / BME680 sensor data Device answers with BME sensor data set on Port 7. 0x86 get time/date Device answers with it's current time on Port 2: bytes 1..4 = time/date in UTC epoch seconds (LSB) byte 5 = time source & status, see below bits 0..3 time source 0x00 = GPS 0x01 = RTC 0x02 = LORA 0x03 = unsynched 0x04 = set (source unknown) bits 4..7 esp32 sntp time status 0x00 = SNTP_SYNC_STATUS_RESET 0x01 = SNTP_SYNC_STATUS_COMPLETED 0x02 = SNTP_SYNC_STATUS_IN_PROGRESS 0x87 sync time/date Device synchronizes it's time/date by calling the preconfigured time source. 0x88 set time/date bytes 1..4 = time/date to set in UTC epoch seconds (MSB, e.g. https://www.epochconverter.com/hex)","title":"Remote control"},{"location":"remotecontrol/#remote-control","text":"The device listenes for remote control commands on LoRaWAN Port 2. Multiple commands per downlink are possible by concatenating them, but must not exceed a maximum of 10 bytes per downlink. Info Settings can be stored in NVRAM to make them persistant (reloaded during device startup / restart). To store settings, use command 0x21 . Send for example 83 86 as Downlink on Port 2 to get battery status and time/date from the device.","title":"Remote control"},{"location":"remotecontrol/#0x01-set-scan-rssi-limit","text":"1 ... 255 used for wifi and bluetooth scan radius (greater values increase scan radius, values 50...110 make sense) 0 = RSSI limiter disabled [default]","title":"0x01 set scan RSSI limit"},{"location":"remotecontrol/#0x02-set-counter-mode","text":"0 = cyclic unconfirmed, mac counter reset after each wifi scan cycle, data is sent only once [default] 1 = cumulative counter, mac counter is never reset 2 = cyclic confirmed, like 0 but data is resent until confirmation by network received","title":"0x02 set counter mode"},{"location":"remotecontrol/#0x03-set-gps-data-onoff","text":"0 = GPS data off 1 = GPS data on, sends GPS data on port 4 (default, use port 1 for mobile pax counter), if GPS is present and has a fix","title":"0x03 set GPS data on/off"},{"location":"remotecontrol/#0x04-set-display-onoff","text":"0 = display off 1 = display on [default]","title":"0x04 set display on/off"},{"location":"remotecontrol/#0x05-set-lora-datarate","text":"0 ... 15 see LoRaWAN regional parameters for details [default: 5] Example for EU868: DataRate Configuration Bit/s 0 LoRa: SF12 / 125 kHz 250 1 LoRa: SF11 / 125 kHz 440 2 LoRa: SF10 / 125 kHz 980 3 LoRa: SF9 / 125 kHz 1760 4 LoRa: SF8 / 125 kHz 3125 5 LoRa: SF7 / 125 kHz 5470 6* LoRa: SF7 / 250 kHz 11000 7* FSK: 50 kbps 50000 8 .. 14 reserved for future use (RFU) 15 ignored (device keeps current setting) *) not supported by TheThingsNetwork","title":"0x05 set LoRa datarate"},{"location":"remotecontrol/#0x06-set-lora-txpower","text":"0 ... 255 desired TX power in dBm [default: 14]","title":"0x06 set LoRa TXpower"},{"location":"remotecontrol/#0x07-set-lora-adaptive-data-rate-mode","text":"0 = ADR off 1 = ADR on [default] If ADR is set to off, SF value is shown inverted on display.","title":"0x07 set LoRa Adaptive Data Rate mode"},{"location":"remotecontrol/#0x08-do-nothing","text":"useful to clear pending commands from LoRaWAN server quere, or to check RSSI on device","title":"0x08 do nothing"},{"location":"remotecontrol/#0x09-reset-functions-send-this-command-unconfirmed-only-to-avoid-boot-loops","text":"0 = restart device (coldstart) 1 = (reserved, currently does nothing) 2 = reset device to factory settings and restart device 3 = flush send queues 4 = restart device (warmstart) 8 = reboot device to maintenance mode (local web server) 9 = reboot device to OTA update via Wifi mode","title":"0x09 reset functions (send this command UNconfirmed only to avoid boot loops!)"},{"location":"remotecontrol/#0x0a-set-payload-send-cycle","text":"5 ... 255 payload send cycle in seconds/2 e.g. 120 -> payload is transmitted each 240 seconds [default]","title":"0x0A set payload send cycle"},{"location":"remotecontrol/#0x0b-set-wifi-channel-hopping-interval-timer","text":"0 ... 255 duration for scanning a wifi channel in seconds/100 e.g. 50 -> each channel is scanned for 500 milliseconds [default] 0 means no hopping, scanning on fixed single channel WIFI_CHANNEL_1","title":"0x0B set Wifi channel hopping interval timer"},{"location":"remotecontrol/#0x0c-set-bluetooth-channel-switch-interval-timer","text":"0 ... 255 duration for scanning a bluetooth advertising channel in seconds/100 e.g. 8 -> each channel is scanned for 80 milliseconds [default]","title":"0x0C set Bluetooth channel switch interval timer"},{"location":"remotecontrol/#0x0e-set-bluetooth-scanner","text":"0 = disabled 1 = enabled [default]","title":"0x0E set Bluetooth scanner"},{"location":"remotecontrol/#0x0f-set-wifi-antenna-switch-works-on-lopylopy4fipy-only","text":"0 = internal antenna [default] 1 = external antenna","title":"0x0F set WIFI antenna switch (works on LoPy/LoPy4/FiPy only)"},{"location":"remotecontrol/#0x10-set-rgb-led-luminosity-works-on-lopylopy4fipy-and-loranode32-shield-only","text":"0 ... 100 percentage of luminosity (100% = full light) e.g. 50 -> 50% of luminosity [default]","title":"0x10 set RGB led luminosity (works on LoPy/LoPy4/FiPy and LoRaNode32 shield only)"},{"location":"remotecontrol/#0x13-set-user-sensor-mode","text":"byte 1 = user sensor number (1..3) byte 2 = sensor mode (0 = disabled / 1 = enabled [default])","title":"0x13 set user sensor mode"},{"location":"remotecontrol/#0x14-set-payload-mask","text":"byte 1 = sensor data payload mask (0..255, meaning of bits see below) 0x01 = COUNT_DATA 0x02 = RESERVED_DATA 0x04 = MEMS_DATA 0x08 = GPS_DATA 0x10 = SENSOR_1_DATA 0x20 = SENSOR_2_DATA 0x40 = SENSOR_3_DATA 0x80 = BATT_DATA bytes can be combined eg COUNT_DATA + SENSOR_1_DATA + BATT_DATA: `0x01 | 0x10 | 0x80 = 0x91`","title":"0x14 set payload mask"},{"location":"remotecontrol/#0x15-set-bme-data-onoff","text":"0 = BME data off 1 = BME data on, sends BME data on port 7 [default]","title":"0x15 set BME data on/off"},{"location":"remotecontrol/#0x16-set-battery-data-onoff","text":"0 = battery data off [default] 1 = battery data on, sends voltage on port 8","title":"0x16 set battery data on/off"},{"location":"remotecontrol/#0x17-set-wifi-scanner","text":"0 = disabled 1 = enabled [default]","title":"0x17 set Wifi scanner"},{"location":"remotecontrol/#0x18-reserved","text":"unused, does nothing","title":"0x18 reserved"},{"location":"remotecontrol/#0x19-set-sleep-cycle","text":"bytes 1..2 = device sleep cycle in seconds/10 (MSB), 0..65535 (0 = no sleep) e.g. {0x04, 0xB0} -> device sleeps 200 minutes after each send cycle [default = 0]","title":"0x19 set sleep cycle"},{"location":"remotecontrol/#0x20-load-device-configuration","text":"Current device runtime configuration will be loaded from NVRAM, replacing current settings immediately (use with care!)","title":"0x20 load device configuration"},{"location":"remotecontrol/#0x21-store-device-configuration","text":"Current device runtime configuration is stored in NVRAM, will be reloaded after restart","title":"0x21 store device configuration"},{"location":"remotecontrol/#0x80-get-device-configuration","text":"Device answers with it's current configuration on Port 3.","title":"0x80 get device configuration"},{"location":"remotecontrol/#0x81-get-device-status","text":"Device answers with it's current status on Port 2.","title":"0x81 get device status"},{"location":"remotecontrol/#0x83-get-battery-status","text":"Device answers with battery voltage on Port 8.","title":"0x83 get battery status"},{"location":"remotecontrol/#0x84-get-device-gps-status","text":"Device answers with it's current status on Port 4.","title":"0x84 get device GPS status"},{"location":"remotecontrol/#0x85-get-bme280-bme680-sensor-data","text":"Device answers with BME sensor data set on Port 7.","title":"0x85 get BME280 / BME680 sensor data"},{"location":"remotecontrol/#0x86-get-timedate","text":"Device answers with it's current time on Port 2: bytes 1..4 = time/date in UTC epoch seconds (LSB) byte 5 = time source & status, see below bits 0..3 time source 0x00 = GPS 0x01 = RTC 0x02 = LORA 0x03 = unsynched 0x04 = set (source unknown) bits 4..7 esp32 sntp time status 0x00 = SNTP_SYNC_STATUS_RESET 0x01 = SNTP_SYNC_STATUS_COMPLETED 0x02 = SNTP_SYNC_STATUS_IN_PROGRESS","title":"0x86 get time/date"},{"location":"remotecontrol/#0x87-sync-timedate","text":"Device synchronizes it's time/date by calling the preconfigured time source.","title":"0x87 sync time/date"},{"location":"remotecontrol/#0x88-set-timedate","text":"bytes 1..4 = time/date to set in UTC epoch seconds (MSB, e.g. https://www.epochconverter.com/hex)","title":"0x88 set time/date"},{"location":"configuration/","text":"Configuration Sensors and Peripherals You can add up to 3 user defined sensors. Insert your sensor's payload scheme in sensor.cpp . More examples and a detailed description can be found in the sensor documentation . Supported Peripherals Bosch BMP180 / BME280 / BME680 SDS011 RTC DS3231 generic serial NMEA GPS I2C Lopy GPS For these peripherals no additional code is needed. To activate configure them in the board's hal file before building the code. See generic.h for all options and for proper configuration of BME280/BME680. BME/ BMP Configuration SDS011 Configuration Custom Sensors Configuration Complete generic.h src/hal/generic.h 37 38 39 40 41 42 43 44 45 46 47 48 49 // BME680 sensor on I2C bus #define HAS_BME 1 // Enable BME sensors in general #define HAS_BME680 GPIO_NUM_21, GPIO_NUM_22 // SDA, SCL #define BME680_ADDR BME680_I2C_ADDR_PRIMARY // connect SDIO of BME680 to GND // BME280 sensor on I2C bus //#define HAS_BME 1 // Enable BME sensors in general //#define HAS_BME280 GPIO_NUM_21, GPIO_NUM_22 // SDA, SCL //#define BME280_ADDR 0x76 // change to 0x77 depending on your wiring // BMP180 sensor on I2C bus //#define HAS_BMP180 //#define BMP180_ADDR 0x77 src/hal/generic.h 51 52 53 54 55 // SDS011 dust sensor settings #define HAS_SDS011 1 // use SDS011 // used pins on the ESP-side: #define SDS_TX 19 // connect to RX on the SDS011 #define SDS_RX 23 // connect to TX on the SDS011 src/hal/generic.h 57 58 59 60 // up to three user defined sensors (if connected) //#define HAS_SENSOR_1 1 // comment out if device has user defined sensor #1 //#define HAS_SENSOR_2 1 // comment out if device has user defined sensor #2 //#define HAS_SENSOR_3 1 // comment out if device has user defined sensor #3 src/hal/generic.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 // clang-format off // upload_speed 115200 // board esp32dev #ifndef _GENERIC_H #define _GENERIC_H #include <stdint.h> // Hardware related definitions for generic ESP32 boards // generic.h is kitchensink with all available options #define HAS_LORA 1 // comment out if device shall not send data via LoRa or has no LoRa #define HAS_SPI 1 // comment out if device shall not send data via SPI // pin definitions for SPI slave interface #define SPI_MOSI GPIO_NUM_23 #define SPI_MISO GPIO_NUM_19 #define SPI_SCLK GPIO_NUM_18 #define SPI_CS GPIO_NUM_5 // enable only if you want to store a local paxcount table on the device #define HAS_SDCARD 1 // this board has an SD-card-reader/writer // Pins for SD-card #define SDCARD_CS (13) #define SDCARD_MOSI (15) #define SDCARD_MISO (2) #define SDCARD_SCLK (14) // enable only if device has these sensors, otherwise comment these lines // tutorial to connect BME sensor see here: // https://sbamueller.wordpress.com/2019/02/26/paxcounter-mit-umweltsensor/ // // in platformio.ini append // lib_deps = <...> ${common.lib_deps_sensors} // for loading necessary libraries // BME680 sensor on I2C bus #define HAS_BME 1 // Enable BME sensors in general #define HAS_BME680 GPIO_NUM_21, GPIO_NUM_22 // SDA, SCL #define BME680_ADDR BME680_I2C_ADDR_PRIMARY // connect SDIO of BME680 to GND // BME280 sensor on I2C bus //#define HAS_BME 1 // Enable BME sensors in general //#define HAS_BME280 GPIO_NUM_21, GPIO_NUM_22 // SDA, SCL //#define BME280_ADDR 0x76 // change to 0x77 depending on your wiring // BMP180 sensor on I2C bus //#define HAS_BMP180 //#define BMP180_ADDR 0x77 // SDS011 dust sensor settings #define HAS_SDS011 1 // use SDS011 // used pins on the ESP-side: #define SDS_TX 19 // connect to RX on the SDS011 #define SDS_RX 23 // connect to TX on the SDS011 // up to three user defined sensors (if connected) //#define HAS_SENSOR_1 1 // comment out if device has user defined sensor #1 //#define HAS_SENSOR_2 1 // comment out if device has user defined sensor #2 //#define HAS_SENSOR_3 1 // comment out if device has user defined sensor #3 #define CFG_sx1276_radio 1 // select LoRa chip //#define CFG_sx1272_radio 1 // select LoRa chip //#define BOARD_HAS_PSRAM // use if board has external SPIRAM, note: this will reduce IRAM0 by 64KB for SPIRAM cache #define DISABLE_BROWNOUT 1 // comment out if you want to keep brownout feature #define HAS_DISPLAY 1 //#define MY_DISPLAY_FLIP 1 // use if display is rotated #define BAT_MEASURE_ADC ADC1_GPIO35_CHANNEL // battery probe GPIO pin -> ADC1_CHANNEL_7 #define BAT_VOLTAGE_DIVIDER 2 // voltage divider 100k/100k on board #define HAS_LED (21) // on board LED #define HAS_BUTTON (39) // on board button #define RGB_LED_COUNT 1 // we have 1 LED #define HAS_RGB_LED FastLED.addLeds<WS2812, GPIO_NUM_0, GRB>(leds, RGB_LED_COUNT); // GPS settings #define HAS_GPS 1 // use on board GPS #define GPS_SERIAL 9600, SERIAL_8N1, GPIO_NUM_12, GPIO_NUM_15 // UBlox NEO 6M RX, TX #define GPS_INT GPIO_NUM_13 // 30ns accurary timepulse, to be external wired on pcb: NEO 6M Pin#3 -> GPIO13 // Pins for I2C interface of OLED Display #define MY_DISPLAY_SDA (4) #define MY_DISPLAY_SCL (15) #define MY_DISPLAY_RST (16) // Settings for on board DS3231 RTC chip #define HAS_RTC MY_DISPLAY_SDA, MY_DISPLAY_SCL // SDA, SCL #define RTC_INT GPIO_NUM_34 // timepulse with accuracy +/- 2*e-6 [microseconds] = 0,1728sec / day // Settings for IF482 interface //#define HAS_IF482 9600, SERIAL_7E1, GPIO_NUM_12, GPIO_NUM_14 // IF482 serial port parameters // Settings for DCF77 interface //#define HAS_DCF77 GPIO_NUM_1 //#define DCF77_ACTIVE_LOW 1 // Pins for LORA chip SPI interface, reset line and interrupt lines #define LORA_SCK (5) #define LORA_CS (18) #define LORA_MISO (19) #define LORA_MOSI (27) #define LORA_RST (14) #define LORA_IRQ (26) #define LORA_IO1 (33) #define LORA_IO2 LMIC_UNUSED_PIN #endif Output of user sensor data can be switched by user remote control command 0x14 sent to Port 2. Output of sensor and peripheral data is internally switched by a bitmask register. Default mask can be tailored by editing cfg.payloadmask initialization value in configmanager.cpp following this scheme: Bit Sensordata Default 0 Paxcounter on 1 unused off 2 BME280/680 on 3 GPS* on 4 User sensor 1 on 5 User sensor 2 on 6 User sensor 3 on 7 Batterylevel off *) GPS data can also be combined with paxcounter payload on port 1, #define GPSPORT 1 in paxcounter.conf to enable src/paxcounter_orig.conf 102 #define GPSPORT 4 // gps - NOTE: set to 1 to send combined GPS+COUNTERPORT payload Power saving mode Paxcounter supports a battery friendly power saving mode. In this mode the device enters deep sleep, after all data is polled from all sensors and the dataset is completeley sent through all user configured channels (LORAWAN / SPI / MQTT / SD-Card). Set #define SLEEPCYCLE in paxcounter.conf to enable power saving mode and to specify the duration of a sleep cycle. src/paxcounter_orig.conf 20 #define SLEEPCYCLE 0 // sleep time after a send cycle [seconds/10], 0 .. 65535; 0 means no sleep [default = 0] Power consumption in deep sleep mode depends on your hardware, i.e. if on board peripherals can be switched off or set to a chip specific sleep mode either by MCU or by power management unit (PMU) as found on TTGO T-BEAM v1.0/V1.1. See power.cpp for power management, and reset.cpp for sleep and wakeup logic. Time sync Paxcounter can keep a time-of-day synced with external or on board time sources. Set #define TIME_SYNC_INTERVAL in paxcounter.conf to enable time sync. src/paxcounter_orig.conf 88 #define TIME_SYNC_INTERVAL 60 // sync time attempt each .. minutes from time source [default = 60], 0 means off Supported external time sources are GPS, LORAWAN network time and LORAWAN application timeserver time. Supported on board time sources are the RTC of ESP32 and a DS3231 RTC chip, both are kept sycned as fallback time sources. Time accuracy depends on board's time base which generates the pulse per second. Supported are GPS PPS, SQW output of RTC, and internal ESP32 hardware timer. Time base is selected by #defines in the board's hal file, see example in generic.h . src/hal/generic.h 87 88 89 90 91 92 93 94 95 96 // Settings for on board DS3231 RTC chip #define HAS_RTC MY_DISPLAY_SDA, MY_DISPLAY_SCL // SDA, SCL #define RTC_INT GPIO_NUM_34 // timepulse with accuracy +/- 2*e-6 [microseconds] = 0,1728sec / day // Settings for IF482 interface //#define HAS_IF482 9600, SERIAL_7E1, GPIO_NUM_12, GPIO_NUM_14 // IF482 serial port parameters // Settings for DCF77 interface //#define HAS_DCF77 GPIO_NUM_1 //#define DCF77_ACTIVE_LOW 1 Tip If your LORAWAN network does not support network time, you can run a Node-Red timeserver application using the enclosed Timeserver code . Configure the MQTT nodes in Node-Red for the LORAWAN application used by your paxocunter device. Time can also be set without precision liability, by simple remote command, see section remote control. Wall clock controller Paxcounter can be used to sync a wall clock which has a DCF77 or IF482 time telegram input. Set #define HAS_IF482 or #define HAS_DCF77 in board's hal file to setup clock controller. Use case of this function is to integrate paxcounter and clock. Accurary of the synthetic DCF77 signal depends on accuracy of on board's time base, see above. Mobile PaxCounter using openSenseMap This describes how to set up a mobile PaxCounter: Follow all steps so far for preparing the device, selecting the packed payload format. In paxcounter.conf set PAYLOAD_OPENSENSEBOX to 1 . src/paxcounter_orig.conf 60 #define PAYLOAD_OPENSENSEBOX 0 // send payload compatible to sensebox.de (swap geo position and pax data) Register a new sensebox on https://opensensemap.org/ . In the sensor configuration select \"TheThingsNetwork\" and set decoding profile to \"LoRa serialization\". Enter your TTN Application and Device ID. Setup decoding option using: [{ \"decoder\" : \"latLng\" },{ \"decoder\" : \"uint16\" , se ns or_id \":\" yourse ns orid\"}] SD-card Data can be stored on SD-card if the board provides an SD card interface, either with SPI or MMC mode. To enable this feature, specify interface mode and hardware pins in board's hal file ( src/hal/<board.h\\> ): #define HAS_SDCARD 1 // SD-card interface, using SPI mode //OR #define HAS_SDCARD 2 // SD-card interface, using MMC mode // Pins for SPI interface #define SDCARD_CS (13) // fill in the correct numbers for your board #define SDCARD_MOSI (15) #define SDCARD_MISO (2) #define SDCARD_SCLK (14) This is an example of a board with MMC SD-card interface: https://www.aliexpress.com/item/32915894264.html . For this board use file src/hal/ttgov21new.h and add the lines given above. Another approach would be this tiny board: https://www.aliexpress.com/item/32424558182.html (needs 5V). In this case you choose the correct file for your ESP32-board in the src/hal-directory and add the lines given above. Edit the pin numbers given in the example, according to your wiring. Data is written on SD-card to a single file. After 3 write operations the data is flushed to the disk to minimize flash write cycles. Thus, up to the last 3 records of data will get lost when the Paxcounter looses power during operation. Format of the resulting file is CSV, thus easy import in LibreOffice, Excel, InfluxDB, etc. Each record contains timestamp (in ISO8601 format), paxcount (wifi and ble) and battery voltage (optional). Voltage is logged if the device has a battery voltage sensor (to be configured in board hal file). File contents example: timestamp,wifi,ble[,voltage] 2022-01-30T21:12:41Z,11,25[,4100] 2022-01-30T21:14:24Z,10,21[,4070] 2022-01-30T21:16:08Z,12,26[,4102] 2022-01-30T21:17:52Z,11,26[,4076] If you want to change this, modify src/sdcard.cpp and include/sdcard.h . Additionally, it's possible to redirect system console output to a plain text file on SD card. This can be useful for debugging headless devices in the field. In paxcounter.conf set SDLOGGING to 1 . src/paxcounter_orig.conf 16 #define SDLOGGING 0 // set to 1 for system logging to SD card (if device has one)","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#sensors-and-peripherals","text":"You can add up to 3 user defined sensors. Insert your sensor's payload scheme in sensor.cpp . More examples and a detailed description can be found in the sensor documentation .","title":"Sensors and Peripherals"},{"location":"configuration/#supported-peripherals","text":"Bosch BMP180 / BME280 / BME680 SDS011 RTC DS3231 generic serial NMEA GPS I2C Lopy GPS For these peripherals no additional code is needed. To activate configure them in the board's hal file before building the code. See generic.h for all options and for proper configuration of BME280/BME680. BME/ BMP Configuration SDS011 Configuration Custom Sensors Configuration Complete generic.h src/hal/generic.h 37 38 39 40 41 42 43 44 45 46 47 48 49 // BME680 sensor on I2C bus #define HAS_BME 1 // Enable BME sensors in general #define HAS_BME680 GPIO_NUM_21, GPIO_NUM_22 // SDA, SCL #define BME680_ADDR BME680_I2C_ADDR_PRIMARY // connect SDIO of BME680 to GND // BME280 sensor on I2C bus //#define HAS_BME 1 // Enable BME sensors in general //#define HAS_BME280 GPIO_NUM_21, GPIO_NUM_22 // SDA, SCL //#define BME280_ADDR 0x76 // change to 0x77 depending on your wiring // BMP180 sensor on I2C bus //#define HAS_BMP180 //#define BMP180_ADDR 0x77 src/hal/generic.h 51 52 53 54 55 // SDS011 dust sensor settings #define HAS_SDS011 1 // use SDS011 // used pins on the ESP-side: #define SDS_TX 19 // connect to RX on the SDS011 #define SDS_RX 23 // connect to TX on the SDS011 src/hal/generic.h 57 58 59 60 // up to three user defined sensors (if connected) //#define HAS_SENSOR_1 1 // comment out if device has user defined sensor #1 //#define HAS_SENSOR_2 1 // comment out if device has user defined sensor #2 //#define HAS_SENSOR_3 1 // comment out if device has user defined sensor #3 src/hal/generic.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 // clang-format off // upload_speed 115200 // board esp32dev #ifndef _GENERIC_H #define _GENERIC_H #include <stdint.h> // Hardware related definitions for generic ESP32 boards // generic.h is kitchensink with all available options #define HAS_LORA 1 // comment out if device shall not send data via LoRa or has no LoRa #define HAS_SPI 1 // comment out if device shall not send data via SPI // pin definitions for SPI slave interface #define SPI_MOSI GPIO_NUM_23 #define SPI_MISO GPIO_NUM_19 #define SPI_SCLK GPIO_NUM_18 #define SPI_CS GPIO_NUM_5 // enable only if you want to store a local paxcount table on the device #define HAS_SDCARD 1 // this board has an SD-card-reader/writer // Pins for SD-card #define SDCARD_CS (13) #define SDCARD_MOSI (15) #define SDCARD_MISO (2) #define SDCARD_SCLK (14) // enable only if device has these sensors, otherwise comment these lines // tutorial to connect BME sensor see here: // https://sbamueller.wordpress.com/2019/02/26/paxcounter-mit-umweltsensor/ // // in platformio.ini append // lib_deps = <...> ${common.lib_deps_sensors} // for loading necessary libraries // BME680 sensor on I2C bus #define HAS_BME 1 // Enable BME sensors in general #define HAS_BME680 GPIO_NUM_21, GPIO_NUM_22 // SDA, SCL #define BME680_ADDR BME680_I2C_ADDR_PRIMARY // connect SDIO of BME680 to GND // BME280 sensor on I2C bus //#define HAS_BME 1 // Enable BME sensors in general //#define HAS_BME280 GPIO_NUM_21, GPIO_NUM_22 // SDA, SCL //#define BME280_ADDR 0x76 // change to 0x77 depending on your wiring // BMP180 sensor on I2C bus //#define HAS_BMP180 //#define BMP180_ADDR 0x77 // SDS011 dust sensor settings #define HAS_SDS011 1 // use SDS011 // used pins on the ESP-side: #define SDS_TX 19 // connect to RX on the SDS011 #define SDS_RX 23 // connect to TX on the SDS011 // up to three user defined sensors (if connected) //#define HAS_SENSOR_1 1 // comment out if device has user defined sensor #1 //#define HAS_SENSOR_2 1 // comment out if device has user defined sensor #2 //#define HAS_SENSOR_3 1 // comment out if device has user defined sensor #3 #define CFG_sx1276_radio 1 // select LoRa chip //#define CFG_sx1272_radio 1 // select LoRa chip //#define BOARD_HAS_PSRAM // use if board has external SPIRAM, note: this will reduce IRAM0 by 64KB for SPIRAM cache #define DISABLE_BROWNOUT 1 // comment out if you want to keep brownout feature #define HAS_DISPLAY 1 //#define MY_DISPLAY_FLIP 1 // use if display is rotated #define BAT_MEASURE_ADC ADC1_GPIO35_CHANNEL // battery probe GPIO pin -> ADC1_CHANNEL_7 #define BAT_VOLTAGE_DIVIDER 2 // voltage divider 100k/100k on board #define HAS_LED (21) // on board LED #define HAS_BUTTON (39) // on board button #define RGB_LED_COUNT 1 // we have 1 LED #define HAS_RGB_LED FastLED.addLeds<WS2812, GPIO_NUM_0, GRB>(leds, RGB_LED_COUNT); // GPS settings #define HAS_GPS 1 // use on board GPS #define GPS_SERIAL 9600, SERIAL_8N1, GPIO_NUM_12, GPIO_NUM_15 // UBlox NEO 6M RX, TX #define GPS_INT GPIO_NUM_13 // 30ns accurary timepulse, to be external wired on pcb: NEO 6M Pin#3 -> GPIO13 // Pins for I2C interface of OLED Display #define MY_DISPLAY_SDA (4) #define MY_DISPLAY_SCL (15) #define MY_DISPLAY_RST (16) // Settings for on board DS3231 RTC chip #define HAS_RTC MY_DISPLAY_SDA, MY_DISPLAY_SCL // SDA, SCL #define RTC_INT GPIO_NUM_34 // timepulse with accuracy +/- 2*e-6 [microseconds] = 0,1728sec / day // Settings for IF482 interface //#define HAS_IF482 9600, SERIAL_7E1, GPIO_NUM_12, GPIO_NUM_14 // IF482 serial port parameters // Settings for DCF77 interface //#define HAS_DCF77 GPIO_NUM_1 //#define DCF77_ACTIVE_LOW 1 // Pins for LORA chip SPI interface, reset line and interrupt lines #define LORA_SCK (5) #define LORA_CS (18) #define LORA_MISO (19) #define LORA_MOSI (27) #define LORA_RST (14) #define LORA_IRQ (26) #define LORA_IO1 (33) #define LORA_IO2 LMIC_UNUSED_PIN #endif Output of user sensor data can be switched by user remote control command 0x14 sent to Port 2. Output of sensor and peripheral data is internally switched by a bitmask register. Default mask can be tailored by editing cfg.payloadmask initialization value in configmanager.cpp following this scheme: Bit Sensordata Default 0 Paxcounter on 1 unused off 2 BME280/680 on 3 GPS* on 4 User sensor 1 on 5 User sensor 2 on 6 User sensor 3 on 7 Batterylevel off *) GPS data can also be combined with paxcounter payload on port 1, #define GPSPORT 1 in paxcounter.conf to enable src/paxcounter_orig.conf 102 #define GPSPORT 4 // gps - NOTE: set to 1 to send combined GPS+COUNTERPORT payload","title":"Supported Peripherals"},{"location":"configuration/#power-saving-mode","text":"Paxcounter supports a battery friendly power saving mode. In this mode the device enters deep sleep, after all data is polled from all sensors and the dataset is completeley sent through all user configured channels (LORAWAN / SPI / MQTT / SD-Card). Set #define SLEEPCYCLE in paxcounter.conf to enable power saving mode and to specify the duration of a sleep cycle. src/paxcounter_orig.conf 20 #define SLEEPCYCLE 0 // sleep time after a send cycle [seconds/10], 0 .. 65535; 0 means no sleep [default = 0] Power consumption in deep sleep mode depends on your hardware, i.e. if on board peripherals can be switched off or set to a chip specific sleep mode either by MCU or by power management unit (PMU) as found on TTGO T-BEAM v1.0/V1.1. See power.cpp for power management, and reset.cpp for sleep and wakeup logic.","title":"Power saving mode"},{"location":"configuration/#time-sync","text":"Paxcounter can keep a time-of-day synced with external or on board time sources. Set #define TIME_SYNC_INTERVAL in paxcounter.conf to enable time sync. src/paxcounter_orig.conf 88 #define TIME_SYNC_INTERVAL 60 // sync time attempt each .. minutes from time source [default = 60], 0 means off Supported external time sources are GPS, LORAWAN network time and LORAWAN application timeserver time. Supported on board time sources are the RTC of ESP32 and a DS3231 RTC chip, both are kept sycned as fallback time sources. Time accuracy depends on board's time base which generates the pulse per second. Supported are GPS PPS, SQW output of RTC, and internal ESP32 hardware timer. Time base is selected by #defines in the board's hal file, see example in generic.h . src/hal/generic.h 87 88 89 90 91 92 93 94 95 96 // Settings for on board DS3231 RTC chip #define HAS_RTC MY_DISPLAY_SDA, MY_DISPLAY_SCL // SDA, SCL #define RTC_INT GPIO_NUM_34 // timepulse with accuracy +/- 2*e-6 [microseconds] = 0,1728sec / day // Settings for IF482 interface //#define HAS_IF482 9600, SERIAL_7E1, GPIO_NUM_12, GPIO_NUM_14 // IF482 serial port parameters // Settings for DCF77 interface //#define HAS_DCF77 GPIO_NUM_1 //#define DCF77_ACTIVE_LOW 1 Tip If your LORAWAN network does not support network time, you can run a Node-Red timeserver application using the enclosed Timeserver code . Configure the MQTT nodes in Node-Red for the LORAWAN application used by your paxocunter device. Time can also be set without precision liability, by simple remote command, see section remote control.","title":"Time sync"},{"location":"configuration/#wall-clock-controller","text":"Paxcounter can be used to sync a wall clock which has a DCF77 or IF482 time telegram input. Set #define HAS_IF482 or #define HAS_DCF77 in board's hal file to setup clock controller. Use case of this function is to integrate paxcounter and clock. Accurary of the synthetic DCF77 signal depends on accuracy of on board's time base, see above.","title":"Wall clock controller"},{"location":"configuration/#mobile-paxcounter-using-opensensemap","text":"This describes how to set up a mobile PaxCounter: Follow all steps so far for preparing the device, selecting the packed payload format. In paxcounter.conf set PAYLOAD_OPENSENSEBOX to 1 . src/paxcounter_orig.conf 60 #define PAYLOAD_OPENSENSEBOX 0 // send payload compatible to sensebox.de (swap geo position and pax data) Register a new sensebox on https://opensensemap.org/ . In the sensor configuration select \"TheThingsNetwork\" and set decoding profile to \"LoRa serialization\". Enter your TTN Application and Device ID. Setup decoding option using: [{ \"decoder\" : \"latLng\" },{ \"decoder\" : \"uint16\" , se ns or_id \":\" yourse ns orid\"}]","title":"Mobile PaxCounter using openSenseMap"},{"location":"configuration/#sd-card","text":"Data can be stored on SD-card if the board provides an SD card interface, either with SPI or MMC mode. To enable this feature, specify interface mode and hardware pins in board's hal file ( src/hal/<board.h\\> ): #define HAS_SDCARD 1 // SD-card interface, using SPI mode //OR #define HAS_SDCARD 2 // SD-card interface, using MMC mode // Pins for SPI interface #define SDCARD_CS (13) // fill in the correct numbers for your board #define SDCARD_MOSI (15) #define SDCARD_MISO (2) #define SDCARD_SCLK (14) This is an example of a board with MMC SD-card interface: https://www.aliexpress.com/item/32915894264.html . For this board use file src/hal/ttgov21new.h and add the lines given above. Another approach would be this tiny board: https://www.aliexpress.com/item/32424558182.html (needs 5V). In this case you choose the correct file for your ESP32-board in the src/hal-directory and add the lines given above. Edit the pin numbers given in the example, according to your wiring. Data is written on SD-card to a single file. After 3 write operations the data is flushed to the disk to minimize flash write cycles. Thus, up to the last 3 records of data will get lost when the Paxcounter looses power during operation. Format of the resulting file is CSV, thus easy import in LibreOffice, Excel, InfluxDB, etc. Each record contains timestamp (in ISO8601 format), paxcount (wifi and ble) and battery voltage (optional). Voltage is logged if the device has a battery voltage sensor (to be configured in board hal file). File contents example: timestamp,wifi,ble[,voltage] 2022-01-30T21:12:41Z,11,25[,4100] 2022-01-30T21:14:24Z,10,21[,4070] 2022-01-30T21:16:08Z,12,26[,4102] 2022-01-30T21:17:52Z,11,26[,4076] If you want to change this, modify src/sdcard.cpp and include/sdcard.h . Additionally, it's possible to redirect system console output to a plain text file on SD card. This can be useful for debugging headless devices in the field. In paxcounter.conf set SDLOGGING to 1 . src/paxcounter_orig.conf 16 #define SDLOGGING 0 // set to 1 for system logging to SD card (if device has one)","title":"SD-card"},{"location":"configuration/custom-sensors/","text":"Custom sensors You can add up to 3 user defined sensors. Insert your sensor's payload scheme in sensor.cpp . The following exampls show how to add a custom temperature and humidty sensor. Add variables or needed libraries Add sensor specific code to sensor_init in sensor.cpp Add sensor specific code to sensor_read function in sensor.cpp Add Payload functions to payload.h and payload.cpp (Optional) Use payload functions in sensor.cpp to send sensor data Example 1: Custom Temperature and Humidity Sensor GY-21 To use a custom sensor you first have to enable the Sensor which you want to use. For this you have to edit or add HAS_SENSOR_1 in either the paxcounter.conf or the hal file of your board. Activate Sensor 1 Activate Sensor 2 Activate Sensor 3 src/paxcounter_orig.conf 132 #define HAS_SENSOR_1 1 src/paxcounter_orig.conf 132 #define HAS_SENSOR_2 1 src/paxcounter_orig.conf 132 #define HAS_SENSOR_3 1 You might also add a constant for your custom sensor in the paxcounter.conf file. This is optional but can be used to identify the sensor type. src/paxcounter_orig.conf 133 #define HAS_GY21 1 // (1) See usage of this in the example below 1. Add variables or needed libraries If you want to use any libary for you custom sensor you have to add it to the platformio.ini file. In this example we use the HTU2xD_SHT2x_Si70xx for the GY-21 sensor. platformio.ini 127 128 129 130 131 [ env : usb ] # (1) upload_protocol = esptool lib_deps = # (2) ${common.lib_deps_all} https://github.com/enjoyneering/HTU2xD_SHT2x_Si70xx.git Selected the env you want to use. In this example we use the usb env. Add the libary to the lib_deps section. Add the import of libary in the sensor.cpp file. sensor.cpp 5 6 7 8 9 #if (HAS_GY21) // (1) #include <HTU2xD_SHT2x_Si70xx.h> HTU2xD_SHT2x_SI70xx ht2x ( HTU2xD_SENSOR , HUMD_12BIT_TEMP_14BIT ); // sensor type, resolution double temperature , humidity ; #endif // HAS_GY21 Define HAS_GY21 either in hal file of your board or in paxcounter.conf file. 2. Add sensor specific code to sensor_init function src/sensor.cpp 1 2 3 4 5 6 7 8 9 #if (HAS_GY21) // (1) if ( ht2x . begin () != true ) // reset sensor, set heater off, set resolution, check power // (sensor doesn't operate correctly if VDD < +2.25v) { ESP_LOGE ( TAG , \"HTU2xD/SHT2x not connected, fail or VDD < +2.25v\" ); } else { ESP_LOGE ( TAG , \"HTU2xD/SHT2x/GY21 found\" ); } #endif // HAS_GY21 Define HAS_GY21 either in hal file of your board or in paxcounter.conf file. 3. Add sensor specific code to sensor_read function In this case we choose that our custom sensor is Sensor 3. This means the data will be sent on SENSOR3PORT which is by default 12 . You can change this in the paxcounter.conf file. src/sensor.cpp 78 79 80 81 82 83 84 85 86 87 88 89 case 3 : #if (HAS_GY21) ESP_LOGE ( TAG , \"Reading Sensor 3, GY21\" ); // (1) temperature = ht2x . readTemperature (); // accuracy +-0.3C in range 0C..60C at 14-bit delay ( 100 ); humidity = ht2x . readHumidity (); // accuracy +-2% in range 20%..80%/25C at 12-bit ESP_LOGE ( TAG , \"GY21: Temperature: %f\" , temperature ); // (2) ESP_LOGE ( TAG , \"GY21: Humidity: %f\" , humidity ); // (3) #endif // HAS_GY21 break ; These logs are only for debugging. You can remove them if you want. These logs are only for debugging. You can remove them if you want. These logs are only for debugging. You can remove them if you want. 4. Payload functions for a custom sensor If you have added your custom sensor code as described before you can also add custom payload function if you need others than the provided ones. For this you have to change two files. First you have to add your payload function to the payload.h file. Example for a custom temperature / humidity payload function src/payload.h 57 void addTempHum ( float temperature , float humidity ); Then you have to add your payload function to the payload.cpp file. You can provide functions for all payload formates (see Payload Formats ) or just add it for the one you are using. Example for a custom temperature / humidity payload function Plain payload format Packed payload format Cayenne payload format src/payload.cpp 128 129 130 131 132 133 134 135 void PayloadConvert::addTempHum ( float temperature , float humidity ) { int16_t temperature = ( int16_t )( temperature ); // float -> int uint16_t humidity = ( uint16_t )( humidity ); // float -> int buffer [ cursor ++ ] = highByte ( temperature ); buffer [ cursor ++ ] = lowByte ( temperature ); buffer [ cursor ++ ] = highByte ( humidity ); buffer [ cursor ++ ] = lowByte ( humidity ); } src/payload.cpp 230 231 232 233 void PayloadConvert::addTempHum ( float temperature , float humidity ) { writeFloat ( temperature ); writeFloat ( humidity ); } src/payload.cpp 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 void PayloadConvert::addTempHum ( float temperature , float humidity ) { // data value conversions to meet cayenne data type definition // 0.1\u00b0C per bit => -3276,7 .. +3276,7 \u00b0C int16_t temp = temperature * 10 ; // 0.5% per bit => 0 .. 128 %C uint16_t hum = humidity * 2 ; #if (PAYLOAD_ENCODER == 3) buffer [ cursor ++ ] = LPP_TEMPERATURE_CHANNEL ; #endif buffer [ cursor ++ ] = LPP_TEMPERATURE ; // 2 bytes 0.1 \u00b0C Signed MSB buffer [ cursor ++ ] = highByte ( temperature ); buffer [ cursor ++ ] = lowByte ( temperature ); #if (PAYLOAD_ENCODER == 3) buffer [ cursor ++ ] = LPP_HUMIDITY_CHANNEL ; #endif buffer [ cursor ++ ] = LPP_HUMIDITY ; // 1 byte 0.5 % Unsigned buffer [ cursor ++ ] = humidity ; } 5. Sending the data After you have added your custom sensor code and payload function you can send the data. For this you have to add the following code to the sensor.cpp file. src/sensor.cpp 78 79 80 81 82 83 84 85 86 87 88 89 90 case 3 : #if (HAS_GY21) ESP_LOGE ( TAG , \"Reading Sensor 3, GY21\" ); temperature = ht2x . readTemperature (); // accuracy +-0.3C in range 0C..60C at 14-bit delay ( 100 ); humidity = ht2x . readHumidity (); // accuracy +-2% in range 20%..80%/25C at 12-bit ESP_LOGE ( TAG , \"GY21: Temperature: %f\" , temperature ); ESP_LOGE ( TAG , \"GY21: Humidity: %f\" , humidity ); payload . addTempHum ( temperature , humidity ); // (1) #endif // HAS_GY21 break ; Add your custom payload function here. Now you can build and upload the code to your ESP. Do not forget to erase the flash before uploading since you probably changed the paxcounter.conf file.","title":"Custom Sensors"},{"location":"configuration/custom-sensors/#custom-sensors","text":"You can add up to 3 user defined sensors. Insert your sensor's payload scheme in sensor.cpp . The following exampls show how to add a custom temperature and humidty sensor. Add variables or needed libraries Add sensor specific code to sensor_init in sensor.cpp Add sensor specific code to sensor_read function in sensor.cpp Add Payload functions to payload.h and payload.cpp (Optional) Use payload functions in sensor.cpp to send sensor data","title":"Custom sensors"},{"location":"configuration/custom-sensors/#example-1-custom-temperature-and-humidity-sensor-gy-21","text":"To use a custom sensor you first have to enable the Sensor which you want to use. For this you have to edit or add HAS_SENSOR_1 in either the paxcounter.conf or the hal file of your board. Activate Sensor 1 Activate Sensor 2 Activate Sensor 3 src/paxcounter_orig.conf 132 #define HAS_SENSOR_1 1 src/paxcounter_orig.conf 132 #define HAS_SENSOR_2 1 src/paxcounter_orig.conf 132 #define HAS_SENSOR_3 1 You might also add a constant for your custom sensor in the paxcounter.conf file. This is optional but can be used to identify the sensor type. src/paxcounter_orig.conf 133 #define HAS_GY21 1 // (1) See usage of this in the example below","title":"Example 1: Custom Temperature and Humidity Sensor GY-21"},{"location":"configuration/custom-sensors/#1-add-variables-or-needed-libraries","text":"If you want to use any libary for you custom sensor you have to add it to the platformio.ini file. In this example we use the HTU2xD_SHT2x_Si70xx for the GY-21 sensor. platformio.ini 127 128 129 130 131 [ env : usb ] # (1) upload_protocol = esptool lib_deps = # (2) ${common.lib_deps_all} https://github.com/enjoyneering/HTU2xD_SHT2x_Si70xx.git Selected the env you want to use. In this example we use the usb env. Add the libary to the lib_deps section. Add the import of libary in the sensor.cpp file. sensor.cpp 5 6 7 8 9 #if (HAS_GY21) // (1) #include <HTU2xD_SHT2x_Si70xx.h> HTU2xD_SHT2x_SI70xx ht2x ( HTU2xD_SENSOR , HUMD_12BIT_TEMP_14BIT ); // sensor type, resolution double temperature , humidity ; #endif // HAS_GY21 Define HAS_GY21 either in hal file of your board or in paxcounter.conf file.","title":"1. Add variables or needed libraries"},{"location":"configuration/custom-sensors/#2-add-sensor-specific-code-to-sensor_init-function","text":"src/sensor.cpp 1 2 3 4 5 6 7 8 9 #if (HAS_GY21) // (1) if ( ht2x . begin () != true ) // reset sensor, set heater off, set resolution, check power // (sensor doesn't operate correctly if VDD < +2.25v) { ESP_LOGE ( TAG , \"HTU2xD/SHT2x not connected, fail or VDD < +2.25v\" ); } else { ESP_LOGE ( TAG , \"HTU2xD/SHT2x/GY21 found\" ); } #endif // HAS_GY21 Define HAS_GY21 either in hal file of your board or in paxcounter.conf file.","title":"2. Add sensor specific code to sensor_init function"},{"location":"configuration/custom-sensors/#3-add-sensor-specific-code-to-sensor_read-function","text":"In this case we choose that our custom sensor is Sensor 3. This means the data will be sent on SENSOR3PORT which is by default 12 . You can change this in the paxcounter.conf file. src/sensor.cpp 78 79 80 81 82 83 84 85 86 87 88 89 case 3 : #if (HAS_GY21) ESP_LOGE ( TAG , \"Reading Sensor 3, GY21\" ); // (1) temperature = ht2x . readTemperature (); // accuracy +-0.3C in range 0C..60C at 14-bit delay ( 100 ); humidity = ht2x . readHumidity (); // accuracy +-2% in range 20%..80%/25C at 12-bit ESP_LOGE ( TAG , \"GY21: Temperature: %f\" , temperature ); // (2) ESP_LOGE ( TAG , \"GY21: Humidity: %f\" , humidity ); // (3) #endif // HAS_GY21 break ; These logs are only for debugging. You can remove them if you want. These logs are only for debugging. You can remove them if you want. These logs are only for debugging. You can remove them if you want.","title":"3. Add sensor specific code to sensor_read function"},{"location":"configuration/custom-sensors/#4-payload-functions-for-a-custom-sensor","text":"If you have added your custom sensor code as described before you can also add custom payload function if you need others than the provided ones. For this you have to change two files. First you have to add your payload function to the payload.h file. Example for a custom temperature / humidity payload function src/payload.h 57 void addTempHum ( float temperature , float humidity ); Then you have to add your payload function to the payload.cpp file. You can provide functions for all payload formates (see Payload Formats ) or just add it for the one you are using. Example for a custom temperature / humidity payload function Plain payload format Packed payload format Cayenne payload format src/payload.cpp 128 129 130 131 132 133 134 135 void PayloadConvert::addTempHum ( float temperature , float humidity ) { int16_t temperature = ( int16_t )( temperature ); // float -> int uint16_t humidity = ( uint16_t )( humidity ); // float -> int buffer [ cursor ++ ] = highByte ( temperature ); buffer [ cursor ++ ] = lowByte ( temperature ); buffer [ cursor ++ ] = highByte ( humidity ); buffer [ cursor ++ ] = lowByte ( humidity ); } src/payload.cpp 230 231 232 233 void PayloadConvert::addTempHum ( float temperature , float humidity ) { writeFloat ( temperature ); writeFloat ( humidity ); } src/payload.cpp 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 void PayloadConvert::addTempHum ( float temperature , float humidity ) { // data value conversions to meet cayenne data type definition // 0.1\u00b0C per bit => -3276,7 .. +3276,7 \u00b0C int16_t temp = temperature * 10 ; // 0.5% per bit => 0 .. 128 %C uint16_t hum = humidity * 2 ; #if (PAYLOAD_ENCODER == 3) buffer [ cursor ++ ] = LPP_TEMPERATURE_CHANNEL ; #endif buffer [ cursor ++ ] = LPP_TEMPERATURE ; // 2 bytes 0.1 \u00b0C Signed MSB buffer [ cursor ++ ] = highByte ( temperature ); buffer [ cursor ++ ] = lowByte ( temperature ); #if (PAYLOAD_ENCODER == 3) buffer [ cursor ++ ] = LPP_HUMIDITY_CHANNEL ; #endif buffer [ cursor ++ ] = LPP_HUMIDITY ; // 1 byte 0.5 % Unsigned buffer [ cursor ++ ] = humidity ; }","title":"4. Payload functions for a custom sensor"},{"location":"configuration/custom-sensors/#5-sending-the-data","text":"After you have added your custom sensor code and payload function you can send the data. For this you have to add the following code to the sensor.cpp file. src/sensor.cpp 78 79 80 81 82 83 84 85 86 87 88 89 90 case 3 : #if (HAS_GY21) ESP_LOGE ( TAG , \"Reading Sensor 3, GY21\" ); temperature = ht2x . readTemperature (); // accuracy +-0.3C in range 0C..60C at 14-bit delay ( 100 ); humidity = ht2x . readHumidity (); // accuracy +-2% in range 20%..80%/25C at 12-bit ESP_LOGE ( TAG , \"GY21: Temperature: %f\" , temperature ); ESP_LOGE ( TAG , \"GY21: Humidity: %f\" , humidity ); payload . addTempHum ( temperature , humidity ); // (1) #endif // HAS_GY21 break ; Add your custom payload function here. Now you can build and upload the code to your ESP. Do not forget to erase the flash before uploading since you probably changed the paxcounter.conf file.","title":"5. Sending the data"}]}